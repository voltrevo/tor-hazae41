#!/usr/bin/env npx tsx
/**
 * Generate ccadbStatic.ts and ccadbHashes.ts from CA certificate sources
 *
 * Usage: npx tsx scripts/generate-ccadb.ts --source=<SOURCE>
 *
 * Available sources:
 *   - certifi: Python certifi CA bundle
 *   - curl: curl's CA bundle
 *   - ccadb: Mozilla CCADB
 *
 * This script fetches certificate data, extracts PEM blocks, and generates:
 * - ccadbStatic.ts: Base64-encoded certificates
 * - ccadbHashes.ts: SPKI hashes for validation (used by ccadbDynamic.ts)
 */

import { X509 } from '@hazae41/x509';
import { Writable } from '@hazae41/binary';
import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';

type CertificateSource = 'certifi' | 'curl' | 'ccadb';

const sourceUrls: Record<CertificateSource, string> = {
  certifi:
    'https://raw.githubusercontent.com/certifi/python-certifi/master/certifi/cacert.pem',
  curl: 'https://curl.se/ca/cacert.pem',
  ccadb:
    'https://ccadb.my.salesforce-sites.com/mozilla/IncludedRootsPEMTxt?TrustBitsInclude=Websites',
};

function getSourceFromArgs(): CertificateSource {
  const sourceArg = process.argv.find(arg => arg.startsWith('--source='));
  if (!sourceArg) {
    console.error(
      `‚ùå Missing required --source parameter. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  const source = sourceArg.split('=')[1] as CertificateSource;
  if (!Object.keys(sourceUrls).includes(source)) {
    console.error(
      `‚ùå Invalid source: ${source}. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  return source;
}

async function fetchAndExtractCerts(
  source: CertificateSource
): Promise<string[]> {
  const url = sourceUrls[source];
  console.log(`Fetching certificates from ${source}...`);

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch certificates: ${response.status} ${response.statusText}`
    );
  }

  const text = await response.text();
  const certs: string[] = [];

  // Extract all PEM certificate blocks
  const certRegex =
    /-----BEGIN CERTIFICATE-----[\s\S]*?-----END CERTIFICATE-----/g;
  const matches = text.match(certRegex);

  if (matches) {
    for (const cert of matches) {
      certs.push(cert.trim());
    }
  }

  return certs;
}

function convertPemToBase64(pem: string): string {
  // Remove PEM headers and newlines, then base64 encode the DER bytes
  const derBase64 = pem
    .replace(/-----BEGIN CERTIFICATE-----/, '')
    .replace(/-----END CERTIFICATE-----/, '')
    .replace(/\s/g, '');
  return derBase64;
}

async function extractCertHash(base64: string): Promise<string | null> {
  try {
    const derBytes = Buffer.from(base64, 'base64');
    const x509 = X509.readAndResolveFromBytesOrThrow(
      X509.Certificate,
      derBytes
    );

    // Extract SPKI hash
    const spki = Writable.writeToBytesOrThrow(
      x509.tbsCertificate.subjectPublicKeyInfo.toDER()
    );
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', spki));
    const hashBase16 = Buffer.from(hash).toString('hex');
    return hashBase16;
  } catch {
    return null;
  }
}

async function generateCCADB() {
  const source = getSourceFromArgs();
  console.log(`Using source: ${source}\n`);

  const pemCerts = await fetchAndExtractCerts(source);
  const base64Certs = pemCerts.map(convertPemToBase64).sort();

  // Extract SPKI hashes for validation
  console.log('Extracting certificate hashes...');
  const hashes: string[] = [];
  for (const base64 of base64Certs) {
    const hash = await extractCertHash(base64);
    if (hash) {
      hashes.push(hash);
    }
  }

  // Generate ccadbStatic.ts with base64 certificates
  const staticOutputPath = path.join(
    process.cwd(),
    'src/cadenas/mods/ccadb/ccadbStatic.ts'
  );
  const staticOutput =
    `// Auto-generated by scripts/generate-ccadb.ts --source=${source}\n` +
    '// Base64-encoded X.509 DER certificates\n' +
    '\n' +
    'export const ccadbStaticBase64: readonly string[] = ' +
    JSON.stringify(base64Certs) +
    ';\n';
  await fs.writeFile(staticOutputPath, staticOutput, 'utf8');

  // Generate ccadbHashes.ts with certificate hashes
  const hashesOutputPath = path.join(
    process.cwd(),
    'src/cadenas/mods/ccadb/ccadbHashes.ts'
  );
  const hashesOutput =
    `// Auto-generated by scripts/generate-ccadb.ts --source=${source}\n` +
    '// SPKI hashes for certificate validation (used by ccadbDynamic.ts)\n' +
    '\n' +
    'export const ccadbCertHashes: readonly string[] = ' +
    JSON.stringify(hashes) +
    ';\n';
  await fs.writeFile(hashesOutputPath, hashesOutput, 'utf8');

  // Run eslint --fix on generated files
  const files = [staticOutputPath, hashesOutputPath];
  for (const file of files) {
    try {
      console.log(`Running eslint --fix on ${path.basename(file)}...`);
      execSync(`eslint --fix "${file}"`, { stdio: 'inherit' });
    } catch (error) {
      console.warn(`‚ö†Ô∏è  eslint --fix failed:`, error);
    }
  }

  console.log(`\n‚úÖ Generated ccadbStatic.ts and ccadbHashes.ts`);
  console.log(`üìä ${base64Certs.length} certificates included`);
  console.log(`üìå Source: ${source}`);
}

generateCCADB().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});

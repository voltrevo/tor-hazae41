#!/usr/bin/env npx tsx
/**
 * Generate ccadbStatic.ts and ccadbHashes.ts from CA certificate sources
 *
 * Usage: npx tsx scripts/generate-ccadb.ts --source=<SOURCE>
 *
 * Available sources:
 *   - certifi: Python certifi CA bundle
 *   - curl: curl's CA bundle
 *   - ccadb: Mozilla CCADB
 *
 * This script fetches certificate data, extracts PEM blocks, and generates:
 * - ccadbStatic.ts: Base64-encoded certificates
 * - ccadbHashes.ts: SPKI hashes for validation (used by ccadbDynamic.ts)
 */

import { X509 } from '@hazae41/x509';
import { Writable } from '@hazae41/binary';
import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';

type CertificateSource = 'certifi' | 'curl' | 'ccadb';

const sourceUrls: Record<CertificateSource, string> = {
  certifi:
    'https://raw.githubusercontent.com/certifi/python-certifi/master/certifi/cacert.pem',
  curl: 'https://curl.se/ca/cacert.pem',
  ccadb:
    'https://ccadb.my.salesforce-sites.com/mozilla/IncludedRootsPEMTxt?TrustBitsInclude=Websites',
};

function getSourceFromArgs(): CertificateSource {
  const sourceArg = process.argv.find(arg => arg.startsWith('--source='));
  if (!sourceArg) {
    console.error(
      `‚ùå Missing required --source parameter. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  const source = sourceArg.split('=')[1] as CertificateSource;
  if (!Object.keys(sourceUrls).includes(source)) {
    console.error(
      `‚ùå Invalid source: ${source}. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  return source;
}

async function fetchAndExtractCerts(
  source: CertificateSource
): Promise<string[]> {
  const url = sourceUrls[source];
  console.log(`Fetching certificates from ${source}...`);

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch certificates: ${response.status} ${response.statusText}`
    );
  }

  const text = await response.text();
  const certs: string[] = [];

  // Extract all PEM certificate blocks
  const certRegex =
    /-----BEGIN CERTIFICATE-----[\s\S]*?-----END CERTIFICATE-----/g;
  const matches = text.match(certRegex);

  if (matches) {
    for (const cert of matches) {
      certs.push(cert.trim());
    }
  }

  return certs;
}

function convertPemToBase64(pem: string): string {
  // Remove PEM headers and newlines, then base64 encode the DER bytes
  const derBase64 = pem
    .replace(/-----BEGIN CERTIFICATE-----/, '')
    .replace(/-----END CERTIFICATE-----/, '')
    .replace(/\s/g, '');
  return derBase64;
}

interface CertMetadata {
  hash: string;
  subject: string;
  issuer: string;
  notAfter?: string;
}

async function extractCertMetadata(
  base64: string
): Promise<CertMetadata | null> {
  try {
    const derBytes = Buffer.from(base64, 'base64');
    const x509 = X509.readAndResolveFromBytesOrThrow(
      X509.Certificate,
      derBytes
    );

    // Extract SPKI hash
    const spki = Writable.writeToBytesOrThrow(
      x509.tbsCertificate.subjectPublicKeyInfo.toDER()
    );
    const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', spki));
    const hashBase16 = Buffer.from(hash).toString('hex');

    // Extract subject DN (first CN if available)
    const subjectX501 = x509.tbsCertificate.subject.toX501OrThrow();
    const subjectMatch = subjectX501.match(/CN=([^,]*)/);
    const subject = subjectMatch ? subjectMatch[1] : subjectX501.split(',')[0];

    // Extract issuer DN (first CN if available)
    const issuerX501 = x509.tbsCertificate.issuer.toX501OrThrow();
    const issuerMatch = issuerX501.match(/CN=([^,]*)/);
    const issuer = issuerMatch ? issuerMatch[1] : issuerX501.split(',')[0];

    // Extract notAfter date
    const validity = x509.tbsCertificate.validity;
    const notAfterJson = validity.toJSON();
    const notAfter = notAfterJson.notAfter as string | undefined;

    return {
      hash: hashBase16,
      subject,
      issuer,
      notAfter,
    };
  } catch {
    return null;
  }
}

async function generateCCADB() {
  const source = getSourceFromArgs();
  console.log(`Using source: ${source}\n`);

  const pemCerts = await fetchAndExtractCerts(source);
  const base64Certs = pemCerts.map(convertPemToBase64).sort();

  // Extract metadata for validation
  console.log('Extracting certificate metadata...');
  const certMetadata: CertMetadata[] = [];
  for (const base64 of base64Certs) {
    const metadata = await extractCertMetadata(base64);
    if (metadata) {
      certMetadata.push(metadata);
    }
  }

  // Generate ccadbStatic.ts with base64 certificates
  const staticOutputPath = path.join(
    process.cwd(),
    'src/cadenas/mods/ccadb/staticCerts.ts'
  );
  const staticOutput =
    `// Auto-generated by scripts/generate-ccadb.ts --source=${source}\n` +
    '// Base64-encoded X.509 DER certificates\n' +
    '\n' +
    'export const staticCerts: string[] = ' +
    JSON.stringify(base64Certs) +
    ';\n';
  await fs.writeFile(staticOutputPath, staticOutput, 'utf8');

  // Generate ccadbHashes.ts with certificate metadata and hashes
  const hashesOutputPath = path.join(
    process.cwd(),
    'src/cadenas/mods/ccadb/certHashes.ts'
  );
  const hashLines: string[] = [];
  hashLines.push(
    `// Auto-generated by scripts/generate-ccadb.ts --source=${source}`
  );
  hashLines.push(
    '// SPKI hashes for certificate validation (used by ccadbDynamic.ts)'
  );
  hashLines.push('');
  hashLines.push('export const certHashes: string[] = [');

  for (let i = 0; i < certMetadata.length; i++) {
    const meta = certMetadata[i];
    hashLines.push(`  // ${meta.subject} (issued by ${meta.issuer})`);
    if (meta.notAfter) {
      hashLines.push(`  // Expires: ${meta.notAfter}`);
    }
    const isLast = i === certMetadata.length - 1;
    if (isLast) {
      hashLines.push(`  '${meta.hash}',`);
    } else {
      hashLines.push(`  '${meta.hash}',`);
      hashLines.push('');
    }
  }

  hashLines.push('];');
  const hashesOutput = hashLines.join('\n') + '\n';
  await fs.writeFile(hashesOutputPath, hashesOutput, 'utf8');

  // Run eslint --fix on generated files
  const files = [staticOutputPath, hashesOutputPath];
  for (const file of files) {
    try {
      console.log(`Running eslint --fix on ${path.basename(file)}...`);
      execSync(`eslint --fix "${file}"`, { stdio: 'inherit' });
    } catch (error) {
      console.warn(`‚ö†Ô∏è  eslint --fix failed:`, error);
    }
  }

  console.log(`\n‚úÖ Generated ccadbStatic.ts and ccadbHashes.ts`);
  console.log(`üìä ${base64Certs.length} certificates included`);
  console.log(`üìå Source: ${source}`);
}

generateCCADB().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});

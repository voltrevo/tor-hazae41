#!/usr/bin/env npx tsx
/**
 * Generate ccadbStatic.ts from CA certificate sources
 *
 * Usage: npx tsx scripts/generate-ccadb.ts --source=<SOURCE>
 *
 * Available sources:
 *   - certifi: Python certifi CA bundle
 *   - curl: curl's CA bundle
 *   - ccadb: Mozilla CCADB
 *
 * This script fetches certificate data, extracts PEM blocks, and generates
 * a TypeScript file with base64-encoded certificates.
 */

import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';

type CertificateSource = 'certifi' | 'curl' | 'ccadb';

const sourceUrls: Record<CertificateSource, string> = {
  certifi:
    'https://raw.githubusercontent.com/certifi/python-certifi/master/certifi/cacert.pem',
  curl: 'https://curl.se/ca/cacert.pem',
  ccadb:
    'https://ccadb.my.salesforce-sites.com/mozilla/IncludedRootsPEMTxt?TrustBitsInclude=Websites',
};

function getSourceFromArgs(): CertificateSource {
  const sourceArg = process.argv.find(arg => arg.startsWith('--source='));
  if (!sourceArg) {
    console.error(
      `‚ùå Missing required --source parameter. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  const source = sourceArg.split('=')[1] as CertificateSource;
  if (!Object.keys(sourceUrls).includes(source)) {
    console.error(
      `‚ùå Invalid source: ${source}. Available options: ${Object.keys(sourceUrls).join(', ')}`
    );
    process.exit(1);
  }

  return source;
}

async function fetchAndExtractCerts(
  source: CertificateSource
): Promise<string[]> {
  const url = sourceUrls[source];
  console.log(`Fetching certificates from ${source}...`);

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch certificates: ${response.status} ${response.statusText}`
    );
  }

  const text = await response.text();
  const certs: string[] = [];

  // Extract all PEM certificate blocks
  const certRegex =
    /-----BEGIN CERTIFICATE-----[\s\S]*?-----END CERTIFICATE-----/g;
  const matches = text.match(certRegex);

  if (matches) {
    for (const cert of matches) {
      certs.push(cert.trim());
    }
  }

  return certs;
}

function convertPemToBase64(pem: string): string {
  // Remove PEM headers and newlines, then base64 encode the DER bytes
  const derBase64 = pem
    .replace(/-----BEGIN CERTIFICATE-----/, '')
    .replace(/-----END CERTIFICATE-----/, '')
    .replace(/\s/g, '');
  return derBase64;
}

async function generateCCADB() {
  const source = getSourceFromArgs();
  console.log(`Using source: ${source}\n`);

  const pemCerts = await fetchAndExtractCerts(source);
  const base64Certs = pemCerts.map(convertPemToBase64).sort();

  // Generate ccadbStatic.ts with base64 certificates
  const staticOutputPath = path.join(
    process.cwd(),
    'src/cadenas/mods/ccadb/ccadbStatic.ts'
  );
  const staticOutput =
    `// Auto-generated by scripts/generate-ccadb.ts --source=${source}\n` +
    '// Base64-encoded X.509 DER certificates\n' +
    '\n' +
    'export const ccadbStaticBase64: readonly string[] = ' +
    JSON.stringify(base64Certs) +
    ';\n';
  await fs.writeFile(staticOutputPath, staticOutput, 'utf8');

  // Run eslint --fix on generated file
  try {
    console.log(`Running eslint --fix on ${staticOutputPath}...`);
    execSync(`eslint --fix "${staticOutputPath}"`, { stdio: 'inherit' });
  } catch (error) {
    console.warn(`‚ö†Ô∏è  eslint --fix failed:`, error);
  }

  console.log(`\n‚úÖ Generated ${staticOutputPath}`);
  console.log(`üìä ${base64Certs.length} certificates included`);
  console.log(`üìå Source: ${source}`);
}

generateCCADB().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});

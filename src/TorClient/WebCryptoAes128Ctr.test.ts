import { test } from '@hazae41/phobos';
import { assert } from '../utils/assert';
import { WebCryptoAes128Ctr } from './WebCryptoAes128Ctr';
import { Bytes } from '../hazae41/bytes';

// Test vectors generated by aes-js implementation
const KEYSTREAM_TEST_VECTORS = [
  {
    key: 'b746a8c778e247e7c5d4a48f5fc12f8a',
    counter: '6584aaf0164ee2d7b1fd6690baeb46d5',
    expectedKeystream:
      'b3e1a14e4f4359a529ba9711d4d9b6e40e74d3aa8f4f333891114094cedd0ee9a1de3ec58b2bfa2c096f08587678893e0a48a18b1bb30e07bac7b195415067f2e45fcafbd35e475381a5c6baf9af1ff3fc048e65032343cbe1646f54478f7b48f38696e8',
  },
  {
    key: '00aecf1bf9a1600c686e819facb92d8c',
    counter: 'e6f5a5bc3e657423425ba3db923de062',
    expectedKeystream:
      '39986f92468076bea838c8ceaaf752b473e405c4539c03332acccbf07977cb9c201a513e45508e1e28d507199faea2bee22539236544622583eaf973416d5da17e2c0491ba044f8c79b714cda351834191e6a56ca03c0b8592c4369f5c64cb7f31693242',
  },
  {
    key: 'c114f47061194334148016097cf10f97',
    counter: 'c724433639373100546ade136f984f3d',
    expectedKeystream:
      '69e0f5e57957525af884384b76d8c61af023839386a7bf9b6bbb65d717b34a33fabafadb18d8db450bdc07b685fb7c41f83a37d2c9aabdad9628ba232b62b03a3c6152576bbfaaf09d47526eb93e73a800673922bcc1e05d7c572b8c4566ba1ff4538e3c',
  },
  {
    key: 'efb39982e7e852b7c9c7ce552b6e6a2a',
    counter: 'c042c1ca91727af757e166658917d7e2',
    expectedKeystream:
      '40cd8f57de003e0f125b05c84bb3f258893baa37e5dcbe0fbe6e386425991dd7c7f02e0518fe7ceef04991700074cc8201246d98ee0cced06bdd71c97f91cc65aca416af42156b55189326108596fec86c22e16a1bc8ba57cfadb89beff6273b490f527d',
  },
  {
    key: 'ffe28d4d7c281ab6ef47777f3b530cdf',
    counter: 'ec404e81003b59ea33f0d9142fae02fa',
    expectedKeystream:
      'b5db5935f485ed819dab4043d0771d44efcefb20038656ba986a18764ec667ed631a0a33ccb71cbcd2ea7cb8251f77717853854f7f8f93a2cba2a9811402ba323d88a830ca3bb8e0cd72408a1303368919b92ccfb5695a7e817a966aaa8eb9ac221eb759',
  },
];

function hexToBytes(hex: string): Bytes {
  const bytes = Bytes.alloc(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}

function bytesToHex(bytes: Bytes): string {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

test('WebCryptoAes128Ctr: getKeystream with various ranges', async () => {
  for (const vector of KEYSTREAM_TEST_VECTORS) {
    const key = hexToBytes(vector.key);
    const counter = hexToBytes(vector.counter);
    const expected = hexToBytes(vector.expectedKeystream);

    const cipher = new WebCryptoAes128Ctr(key, counter);

    try {
      // Test various ranges from the same keystream
      const testRanges = [
        { start: 0n, end: 16n, label: 'First block' },
        { start: 16n, end: 32n, label: 'Second block' },
        { start: 0n, end: 32n, label: 'Two blocks' },
        { start: 5n, end: 23n, label: 'Uneven range' },
        { start: 50n, end: 83n, label: 'Mid-range' },
        { start: 99n, end: 100n, label: 'Last byte' },
        { start: 20n, end: 50n, label: 'Another range' },
      ];

      for (const range of testRanges) {
        const result = await cipher.getKeystream(range.start, range.end);
        const expectedRange = expected.slice(
          Number(range.start),
          Number(range.end)
        );

        assert(
          bytesToHex(result) === bytesToHex(expectedRange),
          `${range.label} keystream mismatch`
        );
      }
    } finally {
      cipher[Symbol.dispose]();
    }
  }
});

test('WebCryptoAes128Ctr: apply_keystream with uneven chunks', async () => {
  for (const vector of KEYSTREAM_TEST_VECTORS) {
    const key = hexToBytes(vector.key);
    const counter = hexToBytes(vector.counter);
    const expectedKeystream = hexToBytes(vector.expectedKeystream);

    const cipher = new WebCryptoAes128Ctr(key, counter);

    try {
      // Apply keystream in uneven chunks
      const chunks = [7, 13, 11, 19, 15, 17, 18];
      let byteOffset = 0;

      for (const chunkSize of chunks) {
        const input = Bytes.alloc(chunkSize);
        const referenceKeystream = expectedKeystream.slice(
          byteOffset,
          byteOffset + chunkSize
        );

        await cipher.apply_keystream(input);

        assert(
          bytesToHex(input) === bytesToHex(referenceKeystream),
          `Chunk at offset ${byteOffset} with size ${chunkSize} mismatch`
        );

        byteOffset += chunkSize;
      }
    } finally {
      cipher[Symbol.dispose]();
    }
  }
});

test('WebCryptoAes128Ctr: apply_keystream with non-zero data', async () => {
  for (const vector of KEYSTREAM_TEST_VECTORS) {
    const key = hexToBytes(vector.key);
    const counter = hexToBytes(vector.counter);
    const expectedKeystream = hexToBytes(vector.expectedKeystream);

    const cipher = new WebCryptoAes128Ctr(key, counter);

    try {
      // Create test input with non-zero pattern
      const testData = Bytes.alloc(100);
      for (let i = 0; i < 100; i++) {
        testData[i] = (i * 7) & 0xff;
      }

      const input = Bytes.from(testData);
      await cipher.apply_keystream(input);

      // Verify each byte: result should be input XOR keystream
      for (let i = 0; i < 100; i++) {
        const expected = testData[i] ^ expectedKeystream[i];
        assert(
          input[i] === expected,
          `Byte ${i} XOR mismatch: expected ${expected}, got ${input[i]}`
        );
      }
    } finally {
      cipher[Symbol.dispose]();
    }
  }
});

test('WebCryptoAes128Ctr: concurrent apply_keystream calls', async () => {
  const vector = KEYSTREAM_TEST_VECTORS[0];
  const key = hexToBytes(vector.key);
  const counter = hexToBytes(vector.counter);
  const expectedKeystream = hexToBytes(vector.expectedKeystream);

  const cipher = new WebCryptoAes128Ctr(key, counter);

  try {
    // Create two concurrent calls to apply_keystream
    // Each should get different keystream portions
    const chunk1 = Bytes.alloc(10);
    const chunk2 = Bytes.alloc(10);

    // Start both concurrently
    await Promise.all([
      cipher.apply_keystream(chunk1),
      cipher.apply_keystream(chunk2),
    ]);

    // chunk1 should match keystream[0:10]
    // chunk2 should match keystream[10:20]
    const expectedChunk1 = expectedKeystream.slice(0, 10);
    const expectedChunk2 = expectedKeystream.slice(10, 20);

    assert(
      bytesToHex(chunk1) === bytesToHex(expectedChunk1),
      `Concurrent chunk1 mismatch: expected ${bytesToHex(expectedChunk1)}, got ${bytesToHex(chunk1)}`
    );

    assert(
      bytesToHex(chunk2) === bytesToHex(expectedChunk2),
      `Concurrent chunk2 mismatch: expected ${bytesToHex(expectedChunk2)}, got ${bytesToHex(chunk2)}`
    );
  } finally {
    cipher[Symbol.dispose]();
  }
});
